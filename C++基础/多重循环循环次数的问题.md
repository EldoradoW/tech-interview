## 🧠 首先：什么是“写 miss”和“缓存污染”？

| 概念         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| **写 miss**  | 写入的数据 **不在 cache 中**，必须从内存读取缓存行再修改，浪费时间 |
| **缓存污染** | 把不相关的数据加载进 cache，占据空间，**赶走真正需要的数据**，导致性能下降 |



------

## 🎯 举个实际例子：写两个数组

我们来对比**两种写入方式**：

### ✅ 情况 A：**内层循环写的是连续地址（局部写）**

```
int A[100][100];

for (int i = 0; i < 100; ++i)
    for (int j = 0; j < 100; ++j)
        A[i][j] += 1;
```

这是**按行写入**，假设 `A` 是 row-major（行主序，C++ 默认），那么：

- 内层循环写入的是连续内存地址：`A[i][0], A[i][1], ..., A[i][99]`
- 对 cache 非常友好：一次加载一个 cache line，就能写很多元素；
- **写入局部性高**：一次 cache 读取有用。

------

### ❌ 情况 B：**内层循环写的是跳跃地址（跳跃写）**

```
int A[100][100];

for (int j = 0; j < 100; ++j)
    for (int i = 0; i < 100; ++i)
        A[i][j] += 1;
```

这是**按列写入**，对于 row-major 来说：

- 每次写 `A[0][j], A[1][j], ..., A[99][j]`；
- 这些地址**跨越多个 cache line**，甚至多个页；
- 导致 cache 不断失效（写 miss），缓存无法重复利用。

------

## 📊 比喻：内存访问就像“搬砖进仓库”

- **连续访问**就像一车车整齐装箱，效率高；
- **跳跃访问**像每次搬一块砖，不仅慢，还堵住仓库门（污染了原本有用的缓存内容）；

------

## 🔥 为什么写 miss 更严重？

写操作不是立即写入内存，而是：

1. 先将所在的“**缓存行（cache line）**”加载到 CPU Cache；
2. 然后修改；
3. 最后由硬件或操作系统根据策略回写到内存。

但如果：

- 写的地址不连续；
- 每次都命中新的缓存行；
- 那么就频繁加载、驱逐缓存，造成**写 miss**；
- 更糟糕的是，这些缓存行可能还把其他重要的数据“挤掉”了，这就是**缓存污染**。

------

## ✅ 内层循环控制写模式，因此**内层循环长短决定 cache 的利用率**

| 模式             | 效果                     |
| ---------------- | ------------------------ |
| 内层循环访问连续 | ✅ cache 命中高、写入高效 |
| 内层循环访问跳跃 | ❌ cache miss 多、污染高  |



------

## ✅ 总结一句话：

> 内层循环越大，它写的地址跨度越大；如果访问模式是“跳跃式”，就会造成频繁写 miss 和 cache 替换，**导致缓存命中率降低、性能下降**。

```c++
#include <iostream>
class Base
{
public:
    void test(int x) 
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

class A : public Base
{
public:
    void test(int x) 
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

class B : public Base
{
public:
    void test(int x) 
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

void TestBase(Base& b) {
    b.test(99);

}

int main() {
    A a;
    B b;
    TestBase(a);
    TestBase(b);
}
```

输出：

> void Base::test(int) 99
>
> void Base::test(int) 99

```cpp
#include <iostream>
class Base
{
public:
    virtual void test(int x)  // 加上virtual,实现了多态
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

class A : public Base
{
public:
    void test(int x) 
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

class B : public Base
{
public:
    void test(int x) 
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

void TestBase(Base& b) {
    b.test(99);

}

int main() {
    A a;
    B b;
    TestBase(a);
    TestBase(b);
}
```

输出：

> virtual void A::test(int) 99
>
> virtual void B::test(int) 99



在创建A对象和B对象的时候都会在对象的头部的8个字节（64位程序）存放一个指针，这个指针会指向虚函数表

虚函数表（vtable）本身是**每个类**只有一份，但**每个含有虚函数的对象**都会包含一个指向它所属类 vtable 的指针（通常叫 vptr）。

```cpp
#include <iostream>
class Base
{
public:
    virtual void test(int x) 
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

class A : public Base
{
public:
    void test(int x) 
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

class B : public Base
{
public:
    void test(int x) 
    {
        std::cout << __PRETTY_FUNCTION__ 
        << " " << x << std::endl;
    }
};

void TestBase(Base& b) {
    b.test(99);
}

using Func = void(*) (void*, int);

int main() {
    A a;
    B b;
    TestBase(a);
    TestBase(b);
    auto vptr = reinterpret_cast<void **>(&a);
  	// 由于vtable是函数指针数组，数组的类型可以表示为void**
    auto vtable = reinterpret_cast<void**>(*vptr);

    auto Test = reinterpret_cast<Func>(vtable[0]);
    Test(&a, 88);
}
```

输出：

> virtual void A::test(int) 99
>
> virtual void B::test(int) 99
>
> virtual void A::test(int) 88






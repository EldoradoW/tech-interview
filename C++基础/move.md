## 1. 函数签名和可调用性

- `void setData(A a)`
  - **接受任意** `A`：既可以传入左值也可以传入右值。
  - 调用时，编译器会 **拷贝（或移动）** 实参到形参 `a`。
- `void setData(A&& a)`
  - **只接受右值**（或被 `std::move` 标记为右值的左值）。
  - `setData(x)`（x 是左值）**不匹配**，必须写 `setData(std::move(x))` 才能调用。

------

## 2. 调用 `setData(std::move(x))` 时的行为

### 2.1 `void setData(A a)`

```
A x{/*…*/};
setData(std::move(x));
```

- `std::move(x)` 把 `x` 转为右值，匹配形参 `A a`。
- 编译器会优先调用 `A` 的 **移动构造**，把 `x` 内部资源“搬”到新参数 `a`。
- **函数内部**用的是 `a`，`x` 里的资源已被置为空或默认状态。
- **额外一次移动**：如果你在函数体里要把 `a` 再存入成员变量或容器，还会再移动／拷贝一次。

### 2.2 `void setData(A&& a)`

```
A x{/*…*/};
setData(std::move(x));
```

- `std::move(x)` 直接匹配形参 `A&& a`，**不再发生构造或拷贝**（只是绑定引用）。
- 函数内部可以直接 **`std::move(a)`** 把资源取走，**只发生一次移动**。

------

## 3. 性能对比

| 调用方式                 | `setData(A a)`      | `setData(A&& a)`               |
| ------------------------ | ------------------- | ------------------------------ |
| 参数传入（std::move(x)） | **1 次移动** 到 `a` | **0** 构造／拷贝（仅引用绑定） |
| 函数内部存储到成员/容器  | **再 1 次移动**     | **1 次移动**                   |
| **总计移动次数**         | 2 次                | 1 次                           |



因此，如果你的 `setData` 最终只是把传入的资源“挪”到成员或容器里，用 `A&&` 可以避免一次多余的移动构造。

------

## 4. 小结

- **`setData(A a)`** 更通用（左值、右值都能传），但对于右值调用会移动两次：一次进参，一次存储。
- **`setData(A&& a)`** 只能接收右值，但可以把第一次“构造”省去，直接引用绑定，后面只做一次移动。
- 如果你只想在 **只接收右值并高效转移资源**，应该用 `void setData(A&&)`；
- 如果你要同时支持左值和右值，而且内部想通过统一逻辑拷贝／移动，`void setData(A)` 会更方便。

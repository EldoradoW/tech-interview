## 🔹 一、值传递（Pass by Value）

```
void func(int x);
```

### ✅ 特点：

- 形参是实参的**拷贝**。
- 修改形参不影响实参。
- 会调用拷贝构造函数（或移动构造函数，C++11 起）。

### 💡 适合：

- 传递**内置类型**（int、char 等）或**小对象**。
- 不希望修改原始数据。

### ❌ 缺点：

- 对于大对象（如 `std::vector`），**性能开销大**。

------

## 🔹 二、左值引用传递（Pass by Lvalue Reference）

```
void func(int &x);
```

### ✅ 特点：

- 传入**左值**（有名字、可取地址的变量）。
- 不产生拷贝，可以直接修改原变量。

### 💡 适合：

- **高效修改原始数据**。
- 避免复制带来的性能损耗。

### ❌ 限制：

- **不能**接收右值（如 `func(10)` 会报错）。

------

## 🔹 三、左值常引用传递（Pass by Const Lvalue Reference）

```
void func(const int &x);
```

### ✅ 特点：

- 可接受**左值**和**右值**。
- 不会复制大对象（避免开销）。
- **不能修改**原始对象。

### 💡 适合：

- 只读访问大对象，如 `std::string`、`std::vector`。
- 可安全传递临时值（右值）。

------

## 🔹 四、右值引用传递（Pass by Rvalue Reference，C++11 起）

```
void func(int &&x);
```

### ✅ 特点：

- 专门接受**右值**（临时对象、`std::move` 之后的值）。
- 允许**资源移动**（而非复制）。
- 典型用于**移动构造函数/移动赋值**。

### 💡 适合：

- 实现**移动语义**（std::move 后交给函数）。
- 优化性能，减少内存分配。

### ❌ 限制：

- **不能接收左值**。

------

## 🔹 五、完美转发（Perfect Forwarding）

```
template <typename T>
void wrapper(T &&arg) {
    func(std::forward<T>(arg));
}
```

### ✅ 特点：

- `T&&` 是**万能引用**（universal reference）——既可接左值又可接右值。
- `std::forward<T>(arg)` 会**保持原始值类别**（左值保持左值，右值保持右值）。
- 是**转发构造函数、工厂函数、包装器函数**的关键技术。

### 💡 适合：

- 写**模板函数**，将参数完整地“原封不动”传给其他函数。
- 实现类似 `std::make_shared`, `std::vector::emplace_back` 的函数。

------

## ✅ 总结对比表：

| 方式                     | 是否拷贝 | 能否修改原值 | 接收左值 | 接收右值 | 是否高效  | 是否常用于模板 |
| ------------------------ | -------- | ------------ | -------- | -------- | --------- | -------------- |
| 值传递                   | ✔️        | ❌            | ✔️        | ✔️        | ❌(大对象) | ❌              |
| 左值引用                 | ❌        | ✔️            | ✔️        | ❌        | ✔️         | ❌              |
| 左值**常**引用           | ❌        | ❌            | ✔️        | ✔️        | ✔️         | ✔️              |
| 右值引用                 | ❌        | ✔️            | ❌        | ✔️        | ✔️         | ✔️              |
| 完美转发 (T&& + forward) | ❌        | ✔️ / ❌        | ✔️        | ✔️        | ✔️         | ✔️✔️✔️            |



------

## 🔍 如何选择？

| 场景                             | 推荐方式                          |
| -------------------------------- | --------------------------------- |
| 传内置类型，如 `int`、`bool`     | **值传递**（简洁无性能问题）      |
| 传大型只读对象，如 `std::string` | **`const T&`**                    |
| 想修改调用者的对象               | **`T&`**                          |
| 转移资源所有权（避免复制）       | **`T&&` + `std::move`**           |
| 模板转发包装函数（如工厂函数）   | **完美转发（`T&&` + `forward`）** |





## 🧭 一句话区分

| 函数           | 功能                            | 用途                                 |
| -------------- | ------------------------------- | ------------------------------------ |
| `std::move`    | **将左值强制转成右值**          | 启用移动语义                         |
| `std::forward` | **完美保留参数的左值/右值属性** | 实现**完美转发**（用于转发函数参数） |



------

## ✅ 示例对比：`std::move`

```
#include <iostream>
#include <string>
#include <vector>

int main() {
    std::vector<std::string> v;
    std::string s = "hello";

    v.push_back(s);             // 拷贝构造
    v.push_back(std::move(s));  // 移动构造，s 变成空字符串

    std::cout << "s: " << s << "\n";  // s 为空
}
```

输出：

```
makefile


复制编辑
s: 
```

------

## ✅ 示例：`unique_ptr` 和 `std::move`

`std::unique_ptr` 是不能被拷贝的，只能移动！

```
#include <iostream>
#include <memory>

std::unique_ptr<int> create() {
    auto ptr = std::make_unique<int>(42);
    return ptr; // 会自动触发移动
}

int main() {
    std::unique_ptr<int> p1 = create();          // 移动构造
    std::unique_ptr<int> p2 = std::move(p1);     // 手动移动

    std::cout << *p2 << std::endl;               // 输出 42
}
```

------

## 🎯 `std::forward` 是做什么的？

它用于“完美转发”：在模板中，根据传入参数的“值类别”（左值/右值）**原样转发**。

### 示例：为什么不能只用 `std::move`

```
template<typename T>
void wrapper(T&& arg) {
    doSomething(std::move(arg));  // 错：总是转成右值
}

template<typename T>
void wrapper2(T&& arg) {
    doSomething(std::forward<T>(arg));  // 对：保持传入参数原来的值类别
}
```

- 如果 `arg` 是左值，`std::forward<T>(arg)` 就是左值
- 如果 `arg` 是右值，`std::forward<T>(arg)` 就是右值

📌 这就是“完美转发”。

------

## ✅ 完美转发实战例子

```
#include <iostream>
#include <utility>

void process(int& x) {
    std::cout << "Lvalue\n";
}
void process(int&& x) {
    std::cout << "Rvalue\n";
}

template<typename T>
void wrapper(T&& val) {
    process(std::forward<T>(val));
}

int main() {
    int a = 10;
    wrapper(a);          // Lvalue
    wrapper(20);         // Rvalue
}
```

------

## ✅ 总结对比

| 特性             | `std::move`            | `std::forward`                |
| ---------------- | ---------------------- | ----------------------------- |
| 用途             | 启用移动语义           | 保留原值类别做完美转发        |
| 参数类型         | 通常用于**左值变量**   | 只用于**转发参数模板**（T&&） |
| 是否强转为右值   | 是                     | 否（保留左值或右值）          |
| 是否触发移动构造 | 是                     | 是（前提是原值是右值）        |
| 使用场景         | 返回值移动、容器优化等 | 转发构造参数、函数调用参数等  |


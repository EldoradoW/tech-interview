# 构造函数的参数允许带默认参数

```cpp
class CP_A
{
public:
  int m_data;
public:
  CP_A(int i = 0)
  // 相当于定义了如下两个构造函数
  // CP_A();
  // CP_A(int a);
};
```

```cpp
class CP_A
{
public:
  int m_data;
public:
  CP_A() : m_data(0) {};
  CP_A(int i = 0);
};

int main() {
  CP_A a; // 会报错，因为对重载函数的调用不明确，不知道调用哪个构造函数
}
```

# 重定义默认参数

```cpp
class CP_A
{
public:
  int m_data;
public:
  CP_A(int i = 0);          // ← 在这里声明了默认参数 = 0
};

CP_A::CP_A(int i = 0)       // ← 这里不该再写 “= 0”
  : m_data(i)
{
}

```

```c
class CP_A
{
public:
    int m_data;
    CP_A(int i = 0);        // ← 在这里声明默认值
};

// 下面不再重复 “= 0”
CP_A::CP_A(int i)
  : m_data(i)
{}
```

# 拷贝构造函数

- 拷贝构造函数通常完成对象成员的一个拷贝
- 格式
  - 类名(const 类名 &变量名);
- 如果用户没有提供拷贝构造函数，系统会自动提供一个默认的拷贝构造函数。用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员

## 场景1 用类的一个实例对象去初始化该类的另一个实例对象

```cpp
class CP_A
{
public:
    int m_data;
public:
  	CP_A(int i = 0) : m_a(i) {}
  	CP_A(const CP_A& a);
};

CP_A::CP_A(const CP_A& a) : m_a(a.m_a)
{
  cout << "Copy:";
}

int main() {
  CP_A a1(10);
  CP_A a2(a1);
}
```

## 场景2 若函数的形参为类的实例对象，在调用函数将实参复制给形参时，系统会自动调用拷贝构造函数



## 场景3 如果函数的返回值是类的实例对象，在该函数返回时，系统会自动调用拷贝构造函数



如果存在拷贝构造函数，系统不会自动生成默认构造函数





```cpp
class CP_A
{
public:
    int m_data;
public:
  	CP_A(int i = 0) : m_a(i) {}
  	CP_A(const CP_A& a);
};

CP_A::CP_A(const CP_A& a) : m_a(a.m_a)
{
  cout << "Copy:";
}

int main() {
  CP_A a1(); // 报错，a1是函数“CP_A(_cdel*)(void)”
  CP_A a2(a1);
}
```




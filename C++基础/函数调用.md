```cpp
#include<stdlib.h>
#include<stdio.h>

char a[] = "password";

int main() {
    int b = 2;
    int* c = malloc(4);
    *c = 0x11223344;

    printf("%p, %p, %p, %p\n", &a, &b, c, main);
}
```



```
a:
        .string "password"
.LC0:
        .string "%p, %p, %p, %p\n"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-12], 2
        mov     edi, 4
        call    malloc
        mov     QWORD PTR [rbp-8], rax
        mov     rax, QWORD PTR [rbp-8]
        mov     DWORD PTR [rax], 287454020
        mov     rdx, QWORD PTR [rbp-8]
        lea     rax, [rbp-12]
        mov     r8d, OFFSET FLAT:main
        mov     rcx, rdx
        mov     rdx, rax
        mov     esi, OFFSET FLAT:a
        mov     edi, OFFSET FLAT:.LC0
        mov     eax, 0
        call    printf
        mov     eax, 0
        leave
        ret
```

在 **x86-64 架构（System V ABI，适用于 Linux 和 macOS）** 下，函数的前 **6 个整数/指针类型参数** 会通过以下 **寄存器** 传递，其顺序如下：

------

### ✅ 整数或指针类型参数传递顺序：

| 参数位置 | 寄存器 |
| -------- | ------ |
| 第 1 个  | `rdi`  |
| 第 2 个  | `rsi`  |
| 第 3 个  | `rdx`  |
| 第 4 个  | `rcx`  |
| 第 5 个  | `r8`   |
| 第 6 个  | `r9`   |



------

### 🧠 示例

假设你有如下函数：

```
void foo(int a, int b, int c, int d, int e, int f);
```

调用 `foo(1, 2, 3, 4, 5, 6);` 时，编译后汇编大致是：

```
mov edi, 1    ; a -> rdi
mov esi, 2    ; b -> rsi
mov edx, 3    ; c -> rdx
mov ecx, 4    ; d -> rcx
mov r8d, 5    ; e -> r8
mov r9d, 6    ; f -> r9
call foo
```

> 注意：`edi` 是 `rdi` 的低 32 位，所以传 int（32 位）时常写 `edi`，传 long（64 位）则用 `rdi`。

------

### 📌 如果参数超过 6 个？

从第 **7 个参数起**，会通过 **栈** 传递，栈上入参会按照从右到左顺序压入栈中。

------

### 🧬 浮点参数（`float`, `double`）：

| 参数类型     | 寄存器组        |
| ------------ | --------------- |
| 浮点类型参数 | `xmm0` ~ `xmm7` |



------

### 📎 小结

| 类型          | 前几个参数的寄存器                     |
| ------------- | -------------------------------------- |
| 整数/指针     | `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9` |
| 浮点（float） | `xmm0` ~ `xmm7`                        |
| 超过寄存器数  | 走栈                                   |

### ✅ `rax` 的主要用途

#### 1. **函数返回值寄存器/算术运算临时**

- 函数返回的结果（如果是整数、指针或浮点数等）会通过 `rax` 返回给调用者。

```
int add(int a, int b) {
    return a + b;
}
```

编译为汇编（伪代码）：

```
mov eax, edi      ; a -> edi
add eax, esi      ; eax = a + b
ret               ; 结果已经在 eax 中
```





> 为什么调用 `printf` 没有再额外执行 `push rbp`，即 `printf` 本身为什么不保存调用者的 `rbp`？

因为**调用函数（caller）负责保存自己的寄存器状态**，包括 `rbp`。而且 `printf` 本身会维护自己的栈帧，它会在自己内部执行 `push rbp`、`mov rbp, rsp` 来建立新的栈帧。所以调用 `printf` 不需要调用者帮它保存 `rbp`。

------

### 🔍 详细解释

#### 📌 1. 函数调用约定（Calling Convention）

在 Linux 和 macOS 的 64 位下（使用的是 **System V AMD64 ABI**），约定如下：

- 参数通过寄存器传递（`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`）
- `rbp`, `rbx`, `r12`~`r15` 是 **callee-saved**（被调用者保存）
- `rax`, `rcx`, `rdx`, `rsi`, `rdi`, `r8`~`r11` 是 **caller-saved**（调用者保存）

👉 `rbp` 是被调用者保存的，所以如果 `printf` 想使用 `rbp`，它会自己保存，不需要调用者操心。

------

#### 📌 2. `printf` 会自己维护自己的栈帧

假设你单步调试进入 `printf`，你会看到它开头也会有：

```
push rbp
mov rbp, rsp
```

这说明 **`printf` 建立了自己的栈帧**，并保存了自己的 `rbp`，与调用者的无关。

------

#### 📌 3. `call` 指令本身做了什么？

当执行 `call printf` 时：

1. 会把 **下一条指令的地址（即 return address）压入栈**；
2. 跳转到 `printf` 的入口；
3. 被调用的 `printf` 再建立它自己的栈帧，可能会 `push rbp`；
4. 返回时，`ret` 会从栈中弹出返回地址，跳回调用点。

**整个过程中，调用者的 `rbp` 不会动，除非你显式去动它。**

------

### 📘 总结

| 角色                          | 是否需要保存 `rbp`？       | 原因                                    |
| ----------------------------- | -------------------------- | --------------------------------------- |
| 调用者（caller）              | ❌ 不需要                   | `rbp` 是 callee-saved，属于被调用者责任 |
| 被调用者（callee，如 printf） | ✅ 需要（如果它使用 `rbp`） | 会自行 `push rbp`, `mov rbp, rsp` 建栈  |



所以，调用 `printf` 时你看不到 `push rbp` 是正常的，它自己会做这件事。调用者只需维护好自己的栈即可。

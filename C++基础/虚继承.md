## 🔍 类的继承结构

```
    GrandParent
      /    \
     /      \
Parent1   Parent2
     \      /
      \    /
       Child
```

- `Parent1` 和 `Parent2` 都**虚继承**自 `GrandParent`。
- `Child` 继承自 `Parent1` 和 `Parent2`。

------

## 📦 每个类的成员分析

- `GrandParent`：1 个 `int`（4 字节）
- `Parent1`：
  - 虚继承指针表指针（一般是 8 字节，在 x64 上）
  - 成员变量 `int p1_val`（4 字节）
- `Parent2`：
  - 同样有虚继承表指针 + `int p2_val`
- `Child`：
  - 成员变量 `int c_val`

------

## 🧠 虚继承的影响

- 虚继承会导致 `GrandParent` 的子对象在内存中被**提升到最上方**，只保留一份 `g_val`。
- **但为了支持虚继承**，`Parent1` 和 `Parent2` 都需要额外的指针来指向 `GrandParent` 的位置（虚基表指针，通常是 8 字节）。
- 整体结构包含了多个间接层和对齐填充。

------

## 📏 x86_64 上的 `sizeof(Child)`

我们可以用一些编译器试验得出常见结果：

```
g++ -m64 -std=c++11 test.cpp -o test && ./test
```

**输出结果通常是：`sizeof(Child) = 40`**

------

## 🧾 解释这个 40 字节怎么来的？

假设是 64 位编译环境（如 Linux/macOS 上的 g++ 编译器）：

1. `GrandParent`：4 字节（加上对齐 8 字节）
2. `Parent1`：
   - 虚继承指针（8 字节）
   - `int p1_val`（4 字节）+ padding
3. `Parent2`：
   - 虚继承指针（8 字节）
   - `int p2_val`（4 字节）+ padding
4. `Child`：`int c_val`（4 字节）+ padding

加起来大约会是：
 `4 (GrandParent)` + `8+4 (Parent1)+4` + `8+4 (Parent2)+4`+ + `4 (Child)` ≈ 40 字节（实际大小取决于布局和对齐）

------

## ✅ 最终答案

```
Size of Child: 40
```

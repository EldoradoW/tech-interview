# 为什么clock多线程下不安全

`clock()` 在多线程环境下**不安全**，主要原因如下：

------

## 🔧 1. `clock()` 返回的是**当前线程的进程总 CPU 时间**

```
clock_t clock(void);
```

它返回的是**自程序启动以来，当前进程所消耗的 CPU 时间总和**，而**不是墙钟时间（实际时间）**。

------

## 🚫 2. 多线程下可能出现以下问题：

### ❌ **误导性时间**（无法测出实际耗时）

在多线程中，多个线程是并发运行的。此时：

- `clock()` 返回的并不是某个线程运行多久了。
- 也不是整个程序“墙钟”上经历了多久。
- 而是所有线程消耗的 CPU 时间的总和（视实现而定）。

🔴 举例：

假设你有两个线程，分别在两个核心上各跑 1 秒：

- 使用 `std::chrono` 测得约 1 秒。
- 使用 `clock()` 会测出 **2 秒**（两个线程的 CPU 时间加起来）。

------

## 🧨 3. 线程之间共享进程计时器

- `clock()` 通常返回的是整个进程的 CPU 消耗时间。
- 多个线程共用同一个计时器，线程切换时 `clock()` 无法区分是哪个线程在执行。
- 因此它并不反映**具体某个线程执行的时间**，也不反映**真实经过的时间**。

------

## ✅ 推荐使用 `std::chrono`

```
#include <chrono>
auto start = std::chrono::high_resolution_clock::now();
// ... your threaded workload ...
auto end = std::chrono::high_resolution_clock::now();
std::chrono::duration<double> elapsed = end - start;
```

- `chrono` 底层可以使用系统稳态时钟 / 高精度时钟。
- 精度高，线程安全，适合真实耗时度量。

------

## 📌 总结

| 特性         | `clock()`                        | `std::chrono`            |
| ------------ | -------------------------------- | ------------------------ |
| 多线程支持   | ❌ 不安全、不准确                 | ✅ 安全，精度高           |
| 返回内容     | CPU 时间（可能是多个线程的总和） | 实际墙钟时间             |
| 用途         | 简单测量进程 CPU 时间            | 推荐用于**实际耗时度量** |
| C++ 推荐程度 | ❌ 过时                           | ✅ C++11 起标准推荐       |



------

如你有多线程程序需要精准计时，请**避免使用 `clock()`，改用 `std::chrono`。**
